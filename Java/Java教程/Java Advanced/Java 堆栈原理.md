# Java 堆栈原理

### 内存的不同用途:

如果您关注网络安全问题，那么一定听过**缓冲区溢**出这个术语。简单说来：缓冲区溢出就是在大缓冲区中的数据向小缓冲区复制的过程中，由于没有注意小缓冲区的边界，“撑爆”了较小的缓冲区，从而冲掉了和小缓冲区相邻内存区域的其他数据而引起的内存问题。缓冲溢出是最常见的内存错误之一，也是攻击者入侵系统时所用到的最强大、最经典的一类漏洞利用方式。
成功地利用缓冲区溢出漏洞可以修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。要透彻地理解这种攻击方式，我们需要回顾一些计算机体系架构方面的基础知识，搞淸楚CPU、寄存器、内存是怎样协同工作而让程序流畅执行的。

根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，**进程使用的内存**都可以按照功能大致分成以下4个部分。

- 代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指令并执行。
- 数据区：用于存储全局变量等。
- 堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配内存和回收内存是堆区的特点。
- 栈区：用于动态地**存储函数**之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。

如果把计算机看成一个有条不紊的1:厂，我们可以得到如下类比。

- CPU是完成工作的工人。
- 数据区、堆区、栈区等则是用来存放原料、半成品、成品等各种东西的场所。
- 存在代码区的指令则告诉CPU要做什么，怎么做，到哪里去领原材料，用什么工具来做，做完以后把成品放到哪个货舱去。
- 值得一提的是，栈除了扮演存放原料、半成品的仓库之外，它还是车间调度主任的办公室。

程序中所使用的**缓冲区**可以是堆区、栈区和存放静态变景的数据区。缓冲区溢出的利用方法和缓冲区到底属于上面哪个内存区域密不可分。

### 栈与系统栈：

从计算机科学的角度来看，栈指的是一种数据结构，是一种先进后出的数据表。栈的最常见操作有两种：压栈（PUSH)、弹栈（POP):用于标识栈的属性也有两个：栈顶（TOP)、栈底（BASE)。
 可以把栈想象成一摞扑克牌。

- PUSH：为栈增加一个元素的操作叫做PUSH，相当于在这摞扑克牌的最上面再放上—张。
- POP：从栈中取出一个元素的操作叫做POP，相当于从这摞扑克牌取出最上面的一张。
- TOP：标识栈顶位置，并且是动态变化的。每做一次PUSH操作，它都会自增1；相反，每做一次POP操作，它会自减1。栈顶元素相当于扑克牌最上面一张，只有这张牌的花色是当前可以看到的。
- BASE：标识栈底位置，它记录着扑克牌最下面一张的位置。BASE用于防止栈空后继续弹栈（牌发完时就不能再去揭牌了）。很明显，一般情况下，BASE是不会变动的。

内存的栈区实际上指的就是系统栈。系统栈由系统自动维护，它用于实现高级语言中函数的调用，对于类似C语言这样的高级语言，系统栈的PUSH、POP等堆栈平衡细节是透明的。
—般说来，只有在使用汇编语言开发程序的时候，才需要和它直接打交道。

### 函数调用时发生了什么？

我们下面就来探究一下高级语言中函数的调用和递归等性质是怎样通过系统栈巧妙实现的。请看如下代码：

```c
int func_B(int arg_B1, int arg_B2)
{
    int var_B1;
    int var_B2;
    var_B1 = arg_B1 + arg_B2;
    var_B2 = arg_B1 - arg_B2;
    return var_B1 * var_B2;
}
int func_A(int arg_A1, int arg_A2)
{
      int var_A;
      var_A = func_B(arg_A1, arg_A2) + arg_A1;
      return var_A;
}
int main(int argc, char** argv, char** envp)
{
      int var_main;
      var_main = func_A(3, 4);
      return 0;
}
```

这段代码经过编译器编译后，各个函数对应的机器指令在代码区中可能是这样分布的，如图2.1.2所示：

<img src="https://upload-images.jianshu.io/upload_images/2327551-66048d1bedc51b4c.png" alt="img" style="zoom:80%;" />

根据操作系统的不问、编译器和编译选项的不同，同一文件不同函数的代码在内存代码区中的分布可能相邻，也可能相离甚远，可能先后有序，也可能无序；但它们都在同一个PE文件的代码所映射的一个“节”里。我们可以简单地把它们在内存代码区中的分布位置理解成是散乱无关的。



### 待续